---
- name: üõ†Ô∏è Mantenimiento Autom√°tico - Windows Server 2019
  hosts: windows-server
  gather_facts: no

  tasks:
    - name: üîç PRUEBA - Comando simple de test
      win_shell: echo "‚úÖ Conexi√≥n SSH funcionando"
      register: test_cmd

    - name: üßπ Limpiar archivos temporales del sistema
      win_shell: |
        Write-Output "Limpiando archivos temporales del sistema..."
        Get-ChildItem "C:\Windows\Temp\*" -ErrorAction SilentlyContinue | Remove-Item -Force -Recurse -ErrorAction SilentlyContinue
        Get-ChildItem "C:\Temp\*" -ErrorAction SilentlyContinue | Remove-Item -Force -Recurse -ErrorAction SilentlyContinue
        Write-Output "Limpieza de sistema completada"
      register: cleanup_system

    - name: üßπ Limpiar archivos temporales de usuario
      win_shell: |
        Write-Output "Limpiando archivos temporales de usuarios..."
        Remove-Item -Path "C:\Users\*\AppData\Local\Temp\*" -Recurse -Force -ErrorAction SilentlyContinue
        Remove-Item -Path "C:\Users\*\AppData\Local\Microsoft\Windows\INetCache\*" -Recurse -Force -ErrorAction SilentlyContinue
        Remove-Item -Path "C:\Users\*\AppData\Local\Microsoft\Windows\Temporary Internet Files\*" -Recurse -Force -ErrorAction SilentlyContinue
        Write-Output "Limpieza de usuarios completada"
      register: cleanup_users

    - name: üõ°Ô∏è INSTALAR TODOS los updates de Windows (sin reinicio autom√°tico)
      win_shell: |
        Write-Output "=== INSTALACI√ìN DE UPDATES (SIN REINICIO AUTOM√ÅTICO) ==="
        
        # M√©todo nativo de Windows
        $Session = New-Object -ComObject "Microsoft.Update.Session"
        $Searcher = $Session.CreateUpdateSearcher()
        
        Write-Output "Buscando updates pendientes..."
        $SearchResult = $Searcher.Search("IsInstalled=0 and Type='Software'")
        
        if ($SearchResult.Updates.Count -eq 0) {
            Write-Output "‚úÖ No hay updates pendientes"
            exit 0
        }
        
        Write-Output "Encontrados $($SearchResult.Updates.Count) updates pendientes:"
        foreach ($Update in $SearchResult.Updates) {
            Write-Output " - $($Update.Title)"
        }
        
        # INSTALAR TODOS los updates pero SIN reinicio autom√°tico
        Write-Output "Instalando TODOS los updates (sin reinicio autom√°tico)..."
        $Installer = $Session.CreateUpdateInstaller()
        $Installer.Updates = $SearchResult.Updates
        $InstallationResult = $Installer.Install()
        
        if ($InstallationResult.ResultCode -eq 2) {
            Write-Output "‚úÖ TODOS los updates instalados correctamente"
            Write-Output "üìã Updates instalados:"
            foreach ($Update in $SearchResult.Updates) {
                Write-Output "   - $($Update.Title)"
            }
        } else {
            Write-Output "‚ö†Ô∏è Algunos updates no se pudieron instalar. C√≥digo: $($InstallationResult.ResultCode)"
        }
      register: windows_updates
      ignore_errors: yes

    - name: üìã Mostrar resultado de actualizaciones
      debug:
        msg: "{{ windows_updates.stdout }}"

    - name: üö® VERIFICAR si se requiere reinicio despu√©s de la instalaci√≥n
      win_shell: |
        Write-Output "=== VERIFICACI√ìN DE REINICIO POST-INSTALACI√ìN ==="
        
        $rebootRequired = $false
        $methods = @()
        
        # M√©todo 1: Windows Update
        if (Test-Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired") {
            $rebootRequired = $true
            $methods += "Windows Update"
        }
        
        # M√©todo 2: Component Based Servicing
        if (Test-Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing\RebootPending") {
            $rebootRequired = $true
            $methods += "Component Based Servicing"
        }
        
        # M√©todo 3: Pending File Rename Operations
        try {
            $pendingRename = Get-ItemProperty "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager" -Name "PendingFileRenameOperations" -ErrorAction SilentlyContinue
            if ($pendingRename -and $pendingRename.PendingFileRenameOperations -ne $null) {
                $rebootRequired = $true
                $methods += "Pending File Rename Operations"
            }
        } catch { }
        
        # M√©todo 4: WMI
        try {
            $wmiReboot = (Get-WmiObject -Class Win32_OperatingSystem).RebootRequired
            if ($wmiReboot) {
                $rebootRequired = $true
                $methods += "WMI"
            }
        } catch { }
        
        if ($rebootRequired) {
            Write-Output "üö® ATENCI√ìN: REINICIO REQUERIDO despu√©s de instalar updates"
            Write-Output "üìã M√©todos que detectan reinicio: $($methods -join ', ')"
            Write-Output "‚è∞ Por favor programe el reinicio MANUAL fuera del horario de producci√≥n"
            Write-Output "üí° Comando para reiniciar: Restart-Computer -Force"
        } else {
            Write-Output "‚úÖ No se requiere reinicio - sistema listo para usar"
        }
        
        Write-Output "`n=== RESUMEN FINAL ==="
        Write-Output "Updates instalados: $($SearchResult.Updates.Count)"
        Write-Output "Reinicio requerido: $(if ($rebootRequired) { 'SI' } else { 'NO' })"
      register: reboot_check

    - name: üìã Mostrar estado de reinicio
      debug:
        msg: "{{ reboot_check.stdout }}"

    - name: üîç Verificar integridad de sistema de archivos
      win_shell: |
        Write-Output "Verificando integridad del sistema de archivos..."
        sfc /verifyonly
        if ($LASTEXITCODE -eq 0) {
          Write-Output "‚úÖ SFC: No se encontraron problemas de integridad"
        } else {
          Write-Output "‚ö†Ô∏è SFC: Se detectaron problemas. Ejecutar 'sfc /scannow' manualmente"
        }
      register: sfc_check

    - name: üìà Verificar rendimiento del sistema
      win_shell: |
        Write-Output "=== MONITOREO DE RENDIMIENTO ==="
        
        # Espacio en disco
        $disk = Get-PSDrive C | Select-Object Used, Free, @{Name="UsedGB";Expression={[math]::Round($_.Used/1GB,2)}}, @{Name="FreeGB";Expression={[math]::Round($_.Free/1GB,2)}}
        Write-Output "Disco C - Usado: $($disk.UsedGB) GB, Libre: $($disk.FreeGB) GB"
        
        # Memoria
        $memory = Get-WmiObject Win32_OperatingSystem
        $freeMemory = [math]::Round($memory.FreePhysicalMemory / 1MB, 2)
        $totalMemory = [math]::Round($memory.TotalVisibleMemorySize / 1MB, 2)
        Write-Output "Memoria - Libre: $freeMemory GB, Total: $totalMemory GB"
      register: performance_check

    - name: üìä Verificar servicios cr√≠ticos
      win_shell: |
        Write-Output "=== ESTADO DE SERVICIOS CR√çTICOS ==="
        $services = @("Spooler", "EventLog", "LanmanServer", "LanmanWorkstation", "Dhcp", "Dnscache")
        foreach ($service in $services) {
          $status = Get-Service -Name $service -ErrorAction SilentlyContinue
          if ($status) {
            Write-Output "$service : $($status.Status)"
          } else {
            Write-Output "$service : No encontrado"
          }
        }
      register: services_check

    - name: üóëÔ∏è Limpiar logs antiguos de Event Viewer
      win_shell: |
        Write-Output "Limpiando logs antiguos de Event Viewer..."
        $logs = @("Application", "System", "Security")
        foreach ($log in $logs) {
          try {
            wevtutil cl $log
            Write-Output "Log limpiado: $log"
          } catch {
            Write-Output "Error limpiando log $log : $($_.Exception.Message)"
          }
        }
        Write-Output "Limpieza de logs completada"
      register: event_cleanup

    - name: ‚úÖ FINALIZADO
      debug:
        msg: "‚úÖ Mantenimiento Windows completado en {{ inventory_hostname }}"
