---
- name: üõ†Ô∏è Mantenimiento Autom√°tico - Windows Server 2019
  hosts: windows-server
  gather_facts: no

  tasks:
    - name: üîç PRUEBA - Comando simple de test
      win_shell: echo "‚úÖ Conexi√≥n SSH funcionando"
      register: test_cmd

    - name: üìã Mostrar resultado test
      debug:
        msg: "{{ test_cmd.stdout }}"

    - name: üìä Verificar informaci√≥n del sistema
      win_shell: systeminfo
      register: system_info_full

    - name: üìã Mostrar informaci√≥n completa del sistema
      debug:
        msg: "{{ system_info_full.stdout }}"

    - name: üßπ Limpiar archivos temporales del sistema
      win_shell: |
        Write-Output "Limpiando archivos temporales del sistema..."
        Get-ChildItem "C:\Windows\Temp\*" -ErrorAction SilentlyContinue | Remove-Item -Force -Recurse -ErrorAction SilentlyContinue
        Get-ChildItem "C:\Temp\*" -ErrorAction SilentlyContinue | Remove-Item -Force -Recurse -ErrorAction SilentlyContinue
        Write-Output "Limpieza de sistema completada"
      register: cleanup_system

    - name: üìã Mostrar resultado limpieza sistema
      debug:
        msg: "{{ cleanup_system.stdout }}"

    - name: üßπ Limpiar archivos temporales de usuario
      win_shell: |
        Write-Output "Limpiando archivos temporales de usuarios..."
        Remove-Item -Path "C:\Users\*\AppData\Local\Temp\*" -Recurse -Force -ErrorAction SilentlyContinue
        Remove-Item -Path "C:\Users\*\AppData\Local\Microsoft\Windows\INetCache\*" -Recurse -Force -ErrorAction SilentlyContinue
        Remove-Item -Path "C:\Users\*\AppData\Local\Microsoft\Windows\Temporary Internet Files\*" -Recurse -Force -ErrorAction SilentlyContinue
        Write-Output "Limpieza de usuarios completada"
      register: cleanup_users

    - name: üìã Mostrar resultado limpieza usuarios
      debug:
        msg: "{{ cleanup_users.stdout }}"

    - name: üõ°Ô∏è Buscar e instalar updates de Windows (sin reinicio autom√°tico)
      win_shell: |
        Write-Output "=== GESTI√ìN DE UPDATES DE WINDOWS ==="
        
        # M√©todo nativo de Windows sin m√≥dulos externos
        $Session = New-Object -ComObject "Microsoft.Update.Session"
        $Searcher = $Session.CreateUpdateSearcher()
        
        Write-Output "Buscando updates pendientes..."
        $SearchResult = $Searcher.Search("IsInstalled=0 and Type='Software'")
        
        if ($SearchResult.Updates.Count -eq 0) {
            Write-Output "‚úÖ No hay updates pendientes"
            exit 0
        }
        
        Write-Output "Encontrados $($SearchResult.Updates.Count) updates pendientes:"
        foreach ($Update in $SearchResult.Updates) {
            Write-Output " - $($Update.Title)"
        }
        
        # Filtrar updates que no requieren reinicio (opcional)
        $UpdatesToInstall = $SearchResult.Updates | Where-Object { $_.Title -notlike "*cumulative*" -and $_.Title -notlike "*servicing stack*" }
        
        if ($UpdatesToInstall.Count -gt 0) {
            Write-Output "Instalando $($UpdatesToInstall.Count) updates..."
            $Installer = $Session.CreateUpdateInstaller()
            $Installer.Updates = $UpdatesToInstall
            $InstallationResult = $Installer.Install()
            
            if ($InstallationResult.ResultCode -eq 2) {
                Write-Output "‚úÖ Updates instalados correctamente"
                
                # Verificar si se requiere reinicio
                $SystemInfo = New-Object -ComObject "Microsoft.Update.SystemInfo"
                if ($SystemInfo.RebootRequired) {
                    Write-Output "üö® ATENCI√ìN: Se requiere REINICIO del sistema"
                    Write-Output "üìã Por favor programe el reinicio fuera del horario de producci√≥n"
                } else {
                    Write-Output "‚úÖ No se requiere reinicio"
                }
            } else {
                Write-Output "‚ö†Ô∏è Algunos updates no se pudieron instalar. C√≥digo: $($InstallationResult.ResultCode)"
            }
        } else {
            Write-Output "‚ÑπÔ∏è Solo updates cr√≠ticos que requieren reinicio disponibles"
            Write-Output "üö® Updates pendientes que requieren reinicio programado:"
            foreach ($Update in $SearchResult.Updates) {
                Write-Output " - $($Update.Title)"
            }
        }
      register: windows_updates
      ignore_errors: yes

    - name: üìã Mostrar resultado de actualizaciones
      debug:
        msg: "{{ windows_updates.stdout }}"

    - name: üö® ALERTA - Verificar si se requiere reinicio
      win_shell: |
        # M√©todos para verificar reinicio pendiente
        $rebootRequired = $false
        $methods = @()
        
        # M√©todo 1: Component Based Servicing
        if (Test-Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing\RebootPending") {
            $rebootRequired = $true
            $methods += "Component Based Servicing"
        }
        
        # M√©todo 2: Windows Update
        if (Test-Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired") {
            $rebootRequired = $true
            $methods += "Windows Update"
        }
        
        # M√©todo 3: Archivo PendingFileRenameOperations
        try {
            $pendingRename = Get-ItemProperty "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager" -Name "PendingFileRenameOperations" -ErrorAction SilentlyContinue
            if ($pendingRename) {
                $rebootRequired = $true
                $methods += "Pending File Rename Operations"
            }
        } catch { }
        
        if ($rebootRequired) {
            Write-Output "üö® REINICIO PENDIENTE REQUERIDO"
            Write-Output "üìã M√©todos que indican reinicio: $($methods -join ', ')"
            Write-Output "‚è∞ Por favor programe el reinicio fuera del horario de producci√≥n"
            Write-Output "üí° Comando para reiniciar: Restart-Computer -Force"
        } else {
            Write-Output "‚úÖ No hay reinicios pendientes"
        }
      register: reboot_check

    - name: üìã Mostrar estado de reinicio
      debug:
        msg: "{{ reboot_check.stdout }}"

    - name: üîç Verificar integridad de sistema de archivos
      win_shell: |
        Write-Output "Verificando integridad del sistema de archivos..."
        sfc /verifyonly
        if ($LASTEXITCODE -eq 0) {
          Write-Output "‚úÖ SFC: No se encontraron problemas de integridad"
        } else {
          Write-Output "‚ö†Ô∏è SFC: Se detectaron problemas. Ejecutar 'sfc /scannow' manualmente"
        }
      register: sfc_check

    - name: üìã Mostrar resultado SFC
      debug:
        msg: "{{ sfc_check.stdout }}"

    - name: üìà Verificar rendimiento del sistema
      win_shell: |
        Write-Output "=== MONITOREO DE RENDIMIENTO ==="
        
        # Memoria disponible
        $memory = Get-Counter "\Memory\Available MBytes" -ErrorAction SilentlyContinue
        if ($memory) {
            $memoryValue = [math]::Round($memory.CounterSamples.CookedValue)
            Write-Output "Memoria disponible: $memoryValue MB"
        } else {
            Write-Output "Memoria disponible: No disponible"
        }
        
        # Uso de CPU
        $cpu = Get-Counter "\Processor(_Total)\% Processor Time" -ErrorAction SilentlyContinue
        if ($cpu) {
            $cpuValue = [math]::Round($cpu.CounterSamples.CookedValue, 2)
            Write-Output "Uso de CPU: $cpuValue %"
        } else {
            Write-Output "Uso de CPU: No disponible"
        }
        
        # Espacio en disco
        $disk = Get-PSDrive C | Select-Object Used, Free, @{Name="UsedGB";Expression={[math]::Round($_.Used/1GB,2)}}, @{Name="FreeGB";Expression={[math]::Round($_.Free/1GB,2)}}
        Write-Output "Disco C - Usado: $($disk.UsedGB) GB, Libre: $($disk.FreeGB) GB"
      register: performance_check

    - name: üìã Mostrar resultado rendimiento
      debug:
        msg: "{{ performance_check.stdout }}"

    - name: üìä Verificar servicios cr√≠ticos
      win_shell: |
        Write-Output "=== ESTADO DE SERVICIOS CR√çTICOS ==="
        $services = @("Spooler", "EventLog", "LanmanServer", "LanmanWorkstation", "Dhcp", "Dnscache")
        foreach ($service in $services) {
          $status = Get-Service -Name $service -ErrorAction SilentlyContinue
          if ($status) {
            Write-Output "$service : $($status.Status)"
          } else {
            Write-Output "$service : No encontrado"
          }
        }
      register: services_check

    - name: üìã Mostrar estado de servicios
      debug:
        msg: "{{ services_check.stdout }}"

    - name: üóëÔ∏è Limpiar logs antiguos de Event Viewer
      win_shell: |
        Write-Output "Limpiando logs antiguos de Event Viewer..."
        $logs = @("Application", "System", "Security")
        foreach ($log in $logs) {
          try {
            wevtutil cl $log
            Write-Output "Log limpiado: $log"
          } catch {
            Write-Output "Error limpiando log $log : $($_.Exception.Message)"
          }
        }
        Write-Output "Limpieza de logs completada"
      register: event_cleanup

    - name: üìã Mostrar resultado limpieza logs
      debug:
        msg: "{{ event_cleanup.stdout }}"

    - name: üìù Generar reporte de mantenimiento
      win_shell: |
        $fecha = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
        $computer = $env:COMPUTERNAME
        
        # Verificar reinicio pendiente
        $rebootRequired = Test-Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired"
        $rebootStatus = if ($rebootRequired) { "üö® REINICIO PENDIENTE - Programar fuera de horario producci√≥n" } else { "‚úÖ No requiere reinicio" }
        
        $reporte = "REPORTE DE MANTENIMIENTO - $fecha`nEquipo: $computer`nEstado Reinicio: $rebootStatus`n`nTareas completadas:`n‚úÖ Limpieza archivos temporales del sistema`n‚úÖ Limpieza archivos temporales de usuarios`n‚úÖ Instalaci√≥n de updates de Windows`n‚úÖ Verificaci√≥n integridad SFC`n‚úÖ Monitoreo de rendimiento`n‚úÖ Verificaci√≥n de servicios cr√≠ticos`n‚úÖ Limpieza de logs de Event Viewer`n`nEjecutado desde Ansible Semaphore"
        $reporte | Out-File "C:\Temp\reporte-mantenimiento.txt" -Encoding UTF8
        Write-Output "Reporte generado en C:\Temp\reporte-mantenimiento.txt"
        if ($rebootRequired) {
            Write-Output "ALERTA: $rebootStatus"
        }
      register: reporte

    - name: üìã Mostrar ubicaci√≥n del reporte
      debug:
        msg: "{{ reporte.stdout }}"

    - name: ‚úÖ FINALIZADO
      debug:
        msg: "‚úÖ Mantenimiento Windows completado en {{ inventory_hostname }}"
